---
title: "Ejemplo: Nuestra propia clase Fraction"
author: "Carlos Zamora"
date: "2023-08-06"
categories:
    - POO
---

En este blog documentaré la creación de mi propia clase para representar un número racional.

Empezaremos con una clase `MyFraction` sencilla que tiene el constructor más evidente que recibe dos números enteros que representan el numerador y el denominador. También he agregado el método `__str__()` para poder mostrar nuestras instancias de manera legible con `print()`. 

```python
class MyFraction:
    
    def __init__(self, numerator:int, denominator:int = 1) -> None:
        self.numerator = numerator
        self.denominator = denominator

    def __str__(self) -> str:
        return f"{self.numerator}/{self.denominator}"
    

if __name__ == "__main__":
    
    q1 = MyFraction(5,3)
    q2 = MyFraction(8)
    print(q1)
    print(q2)
```

Salida:

```
5/3
8/1
```

Vemos que este código funciona bien cuando recibimos 1 o  2 enteros, sin embargo, puede no tener el efecto deseado al recibir valores de otro tipo:

```python
if __name__ == "__main__":
    
    q1 = MyFraction("hola",3)
    q2 = MyFraction(3.14, 2.72)
    print(q1)
    print(q2)
```

Salida:
```
hola/3
3.14/2.72
```

Podemos ver en la salida que nuestra instancia ya no representa un racional propiamente, esto se debe a que Python es un lenguaje de tipado dinámico que no revisa los tipos de datos. Podemos pensar que la solución a este problema implementar la revisión de tipos nosotros mismos. 

Antes de continuar, delimitemos nuestra clase, específicamente nuestro constructor:

1. Recibirá 1 o 2 variables que representen enteros, ó
2. Recibirá 1 variable que represente un flotante, ó
3. Recibirá otra fracción.