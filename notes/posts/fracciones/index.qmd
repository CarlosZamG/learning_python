---
title: "Ejemplo: Nuestra propia clase Fraction"
author: "Carlos Zamora"
date: "2023-08-06"
categories:
    - POO
---

En este blog documentar茅 la creaci贸n de mi propia clase para representar un n煤mero racional.

Empezaremos con una clase `MyFraction` sencilla que tiene el constructor m谩s evidente que recibe dos n煤meros enteros que representan el numerador y el denominador. Tambi茅n he agregado el m茅todo `__str__()` para poder mostrar nuestras instancias de manera legible con `print()`. 

```python
class MyFraction:
    
    def __init__(self, numerator:int, denominator:int = 1) -> None:
        self.numerator = numerator
        self.denominator = denominator

    def __str__(self) -> str:
        return f"{self.numerator}/{self.denominator}"
    

if __name__ == "__main__":
    
    q1 = MyFraction(5,3)
    q2 = MyFraction(8)
    print(q1)
    print(q2)
```

Salida:

```
5/3
8/1
```

Vemos que este c贸digo funciona bien cuando recibimos 1 o  2 enteros, sin embargo, puede no tener el efecto deseado al recibir valores de otro tipo:

```python
if __name__ == "__main__":
    
    q1 = MyFraction("hola",3)
    q2 = MyFraction(3.14, 2.72)
    print(q1)
    print(q2)
```

Salida:
```
hola/3
3.14/2.72
```

Podemos ver en la salida que nuestra instancia ya no representa un racional propiamente, esto se debe a que Python es un lenguaje de tipado din谩mico que no revisa los tipos de datos. Podemos pensar que la soluci贸n a este problema implementar la revisi贸n de tipos nosotros mismos. 

Antes de continuar, delimitemos nuestra clase, espec铆ficamente nuestro constructor:

1. Recibir谩 1 o 2 variables que representen enteros, 贸
2. Recibir谩 1 variable que represente un flotante, 贸
3. Recibir谩 otra fracci贸n.

Este es el c贸digo modificado:
```python
class MyFraction:
    
    def __init__(self, arg1, arg2 = 1) -> None:
        
        if isinstance(arg1, int) and isinstance(arg2, int):
            if arg2 == 0:
                raise ZeroDivisionError("the denominator should be non-zero") 
            elif arg1 == 0:
                self.numerator = arg1
                self.denominator = 1
            else:
                self.numerator = arg1
                self.denominator = arg2
                self.simplify()
        elif isinstance(arg1, float) and arg2 == 1:
            intarg = int(arg1)
            while arg1 - intarg > 0.00001:
                arg1 *= 10
                arg2 *= 10
                intarg = int(arg1)

            self.numerator = intarg
            self.denominator = arg2
            self.simplify()
        elif isinstance(arg1, MyFraction) and arg2 == 1:
            self.numerator = arg1.numerator 
            self.denominator = arg1.denominator
        else:
            raise TypeError("unsupported types of arguments")

        

    def simplify(self):
        
        abs_n = abs(self.numerator)
        abs_d = abs(self.denominator)
        d = self.gcd(abs_n,abs_d)
        self.numerator //= d
        self.denominator //= d

        if self.denominator < 0:
            self.numerator *= -1
            self.denominator *= -1

    def __str__(self) -> str:
        return f"{self.numerator}/{self.denominator}"
    
    @staticmethod
    def gcd(a:int, b:int) -> int:
        
        if a<b:
            a,b = b,a
        
        r = a % b
        while r != 0:
            
            a = b
            b = r
            r = a % b

        return b
    

if __name__ == "__main__":
    
    q1 = MyFraction(12,8)
    print(q1)

    q2 = MyFraction(32,-8)
    print(q2)

    q3 = MyFraction(3.14)
    print(q3)

    q4 = MyFraction(q1)
    print(q4)

    q5 = MyFraction("Hola",3)
    print(q5)    
```

Salida:

```
3/2
-4/1
157/50
3/2
Traceback (most recent call last):
  File ".\notes\posts\fracciones\ownfraction.py", line 78, in <module>
    q5 = MyFraction("Hola",3)
  File ".\notes\posts\fracciones\ownfraction.py", line 29, in __init__
    raise TypeError("unsupported types of arguments")
TypeError: unsupported types of arguments
```

Vemos que nuestro c贸digo parece funcionar, sin embargo [PEP 443](https://peps.python.org/pep-0443/#abstract) dice que *"actualmente es un antipatr贸n com煤n para el c贸digo de Python inspeccionar los tipos de argumentos recibidos para decidir qu茅 hacer con los objetos."* 别别

As铆 que esta no parece ser una forma pyth贸nica de hacerlo.

Una mejor forma de tener m煤ltiples constructores es utilizar **m茅todos de clase**, estos son m茅todos que pertenecen a la clase y no es necesario instanciar un objeto para poder utilizarlos.

```python
class MyFraction:
    
    def __init__(self, p:int, q:int = 1) -> None:
        
        if isinstance(p, int) and isinstance(q, int):
            if q == 0:
                raise ZeroDivisionError("the denominator should be non-zero") 
            elif p == 0:
                self.numerator = p
                self.denominator = 1
            else:
                self.numerator = p
                self.denominator = q
                self.simplify()
        else:
            raise TypeError("arguments should be of integer type")
    
    @classmethod
    def from_float(cls, f:float):

        if isinstance(f, float):
            denominator = 1 
            intarg = int(f)
            while f - intarg > 0.00001:
                f *= 10
                denominator *= 10
                intarg = int(f)

            return cls(intarg, denominator) 
        
        else:
            raise TypeError("argument should be of float type")

    @classmethod
    def from_fraction(cls, fraction):

        if isinstance(fraction, MyFraction):
            return cls(fraction.numerator, fraction.denominator)
        else:
            raise TypeError("argument should be an instance of MyFraction")
        

    def simplify(self):
        
        abs_n = abs(self.numerator)
        abs_d = abs(self.denominator)
        d = self.gcd(abs_n,abs_d)
        self.numerator //= d
        self.denominator //= d

        if self.denominator < 0:
            self.numerator *= -1
            self.denominator *= -1

    def __str__(self) -> str:
        return f"{self.numerator}/{self.denominator}"
    
    @staticmethod
    def gcd(a:int, b:int) -> int:
        
        if a<b:
            a,b = b,a
        
        r = a % b
        while r != 0:
            
            a = b
            b = r
            r = a % b

        return b
    

if __name__ == "__main__":
    
    q1 = MyFraction(12,8)
    print(q1)

    q2 = MyFraction(32,-8)
    print(q2)

    q3 = MyFraction.from_float(3.14)
    print(q3)

    q4 = MyFraction.from_fraction(q2)
    print(q4)

    q5 = MyFraction.from_float("Hola")
    print(q5)    
```
Salida:
```
3/2
-4/1
157/50
-4/1
Traceback (most recent call last):
  File "C:\Users\Carlos\Desktop\ESFM\learning_python\notes\posts\fracciones\ownfraction.py", line 88, in <module>  
    q5 = MyFraction.from_float("Hola")
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\Carlos\Desktop\ESFM\learning_python\notes\posts\fracciones\ownfraction.py", line 32, in from_float
    raise TypeError("argument should be of float type")
TypeError: argument should be of float type
```

En el c贸digo anterior definimos los m茅todos de clase `from_float()` y `from_fraction()` para tener constructores alternativos que reciben diferentes tipos de argumentos y crean instancias de `MyFraction`.

:::{.callout-tip}
Una convenci贸n popular en Python es usar el prefijo `from` para los constructores definidos como m茅todos de clase.
:::

### Utilizando el decorador `@singledispatchmethod`.

Podemos encontrar la siguiente definici贸n en [PEP 443](https://peps.python.org/pep-0443/):

:::{.callout-tip}
Una **funci贸n gen茅rica** se compone de m煤ltiples funciones que implementan la misma operaci贸n para diferentes tipos. La implementaci贸n que debe usarse durante una llamada est谩 determinada por el algoritmo de env铆o (*dispatch algorithm*). Cuando la implementaci贸n se elige en funci贸n del tipo de un solo argumento, esto se conoce como env铆o 煤nico o **single dispatch**.
:::

A partir de Python 3.8 podemos utilizar el decorador `@singledispatchmethod` para convertir un m茅todo en una funci贸n gen茅rica de env铆o m煤ltiple.

```python
from functools import singledispatchmethod

class MyFraction:

    @singledispatchmethod
    def __init__(self, arg1, arg2) -> None:
        raise TypeError(f"unsupported type of arguments")

    @__init__.register(int)
    def from_integers(self, p:int, q:int = 1) -> None:

        if not isinstance(q,int):
          raise TypeError("the denominator should be non-zero")

        if q == 0:
            raise ZeroDivisionError("the denominator should be non-zero")
        elif p == 0:
            self.numerator = p
            self.denominator = 1
        else:
            self.numerator = p
            self.denominator = q
            self.simplify()

    @__init__.register(float)
    def from_float(self, f:float):

        denominator = 1
        intarg = int(f)
        while f - intarg > 0.00001:
            f *= 10
            denominator *= 10
            intarg = int(f)

        self.numerator = intarg
        self.denominator = denominator
        self.simplify()

    @classmethod
    def from_fraction(cls, fraction):

        if isinstance(fraction, MyFraction):
            return cls(fraction.numerator, fraction.denominator)
        else:
            raise TypeError("argument should be an instance of MyFraction")


    def simplify(self):

        abs_n = abs(self.numerator)
        abs_d = abs(self.denominator)
        d = self.gcd(abs_n,abs_d)
        self.numerator //= d
        self.denominator //= d

        if self.denominator < 0:
            self.numerator *= -1
            self.denominator *= -1

    def __str__(self) -> str:
        return f"{self.numerator}/{self.denominator}"

    @staticmethod
    def gcd(a:int, b:int) -> int:

        if a<b:
            a,b = b,a

        r = a % b
        while r != 0:

            a = b
            b = r
            r = a % b

        return b


if __name__ == "__main__":

    q1 = MyFraction(12,8)
    print(q1)

    q2 = MyFraction(32,-8)
    print(q2)

    q3 = MyFraction(3.14)
    print(q3)

    q4 = MyFraction.from_fraction(q2)
    print(q4)
```

Salida:

```
3/2
-4/1
157/50
-4/1
```

En el c贸digo anterior hemos convertido el m茅todo `__init__()` en una funci贸n gen茅rica que tiene una implementaci贸n diferente para enteros (`from_integers()`) y para flotantes (`from_float()`). Sin embargo `from_fraction()` sigue siendo un m茅todo de clase debido a que al agregarlo como una implementaci贸n m谩s con `__init__.register(MyFraction)`, tenemos un error que nos dice que `MyFraction` no est谩 definida.