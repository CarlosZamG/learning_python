[
  {
    "objectID": "posts/hola-mundo/index.html",
    "href": "posts/hola-mundo/index.html",
    "title": "Hola Mundo",
    "section": "",
    "text": "Hola Mundo!!!!\nDecid√≠ empezar este blog para documentar mi aprendizaje en Python.\nLos temas que planeo aprender (por ahora) son los siguientes:\n\n1. Interpretado vs Compilado.\n\n\n2. Funciones.\n\nScope.\nPar√°metros y argumentos.\nArgumentos opcionales y par√°metros con un valor por default.\nargs y kwargs.\nFunciones lambda.\nmap(),filter(), reduce().\n\n\n\n3. Estructuras de datos y strings.\n\nListas.\nIndexing y slicing.\nTuplas.\nDiccionarios\nArrays.\nFormateo de strings.\nComprenhensions.\n\n\n\n4. Programaci√≥n Orientada a Objetos.\n\nClases.\nHerencia.\nSobrecarga de operadores.\nEnum.\n\n\n\n4. Otros:\n\nManejo de archivos.\nExcepciones.\nassert.\nDecoradores."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Aprendiendo Python",
    "section": "",
    "text": "Ejemplo: Nuestra propia clase Fraction\n\n\n\n\n\n\n\nPOO\n\n\n\n\n\n\n\n\n\n\n\nAug 17, 2023\n\n\nCarlos Zamora\n\n\n\n\n\n\n  \n\n\n\n\nHola Mundo\n\n\n\n\n\n\n\n\n\n\n\n\nAug 5, 2023\n\n\nCarlos Zamora\n\n\n\n\n\n\nNo hay resultados"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/fracciones/index.html",
    "href": "posts/fracciones/index.html",
    "title": "Ejemplo: Nuestra propia clase Fraction",
    "section": "",
    "text": "En este blog documentar√© la creaci√≥n de mi propia clase para representar un n√∫mero racional.\nEmpezaremos con una clase MyFraction sencilla que tiene el constructor m√°s evidente que recibe dos n√∫meros enteros que representan el numerador y el denominador. Tambi√©n he agregado el m√©todo __str__() para poder mostrar nuestras instancias de manera legible con print().\nclass MyFraction:\n    \n    def __init__(self, numerator:int, denominator:int = 1) -&gt; None:\n        self.numerator = numerator\n        self.denominator = denominator\n\n    def __str__(self) -&gt; str:\n        return f\"{self.numerator}/{self.denominator}\"\n    \n\nif __name__ == \"__main__\":\n    \n    q1 = MyFraction(5,3)\n    q2 = MyFraction(8)\n    print(q1)\n    print(q2)\nSalida:\n5/3\n8/1\nVemos que este c√≥digo funciona bien cuando recibimos 1 o 2 enteros, sin embargo, puede no tener el efecto deseado al recibir valores de otro tipo:\nif __name__ == \"__main__\":\n    \n    q1 = MyFraction(\"hola\",3)\n    q2 = MyFraction(3.14, 2.72)\n    print(q1)\n    print(q2)\nSalida:\nhola/3\n3.14/2.72\nPodemos ver en la salida que nuestra instancia ya no representa un racional propiamente, esto se debe a que Python es un lenguaje de tipado din√°mico que no revisa los tipos de datos. Podemos pensar que la soluci√≥n a este problema implementar la revisi√≥n de tipos nosotros mismos.\nAntes de continuar, delimitemos nuestra clase, espec√≠ficamente nuestro constructor:\n\nRecibir√° 1 o 2 variables que representen enteros, √≥\nRecibir√° 1 variable que represente un flotante, √≥\nRecibir√° otra fracci√≥n.\n\nEste es el c√≥digo modificado:\nclass MyFraction:\n    \n    def __init__(self, arg1, arg2 = 1) -&gt; None:\n        \n        if isinstance(arg1, int) and isinstance(arg2, int):\n            if arg2 == 0:\n                raise ZeroDivisionError(\"the denominator should be non-zero\") \n            elif arg1 == 0:\n                self.numerator = arg1\n                self.denominator = 1\n            else:\n                self.numerator = arg1\n                self.denominator = arg2\n                self.simplify()\n        elif isinstance(arg1, float) and arg2 == 1:\n            intarg = int(arg1)\n            while arg1 - intarg &gt; 0.00001:\n                arg1 *= 10\n                arg2 *= 10\n                intarg = int(arg1)\n\n            self.numerator = intarg\n            self.denominator = arg2\n            self.simplify()\n        elif isinstance(arg1, MyFraction) and arg2 == 1:\n            self.numerator = arg1.numerator \n            self.denominator = arg1.denominator\n        else:\n            raise TypeError(\"unsupported types of arguments\")\n\n        \n\n    def simplify(self):\n        \n        abs_n = abs(self.numerator)\n        abs_d = abs(self.denominator)\n        d = self.gcd(abs_n,abs_d)\n        self.numerator //= d\n        self.denominator //= d\n\n        if self.denominator &lt; 0:\n            self.numerator *= -1\n            self.denominator *= -1\n\n    def __str__(self) -&gt; str:\n        return f\"{self.numerator}/{self.denominator}\"\n    \n    @staticmethod\n    def gcd(a:int, b:int) -&gt; int:\n        \n        if a&lt;b:\n            a,b = b,a\n        \n        r = a % b\n        while r != 0:\n            \n            a = b\n            b = r\n            r = a % b\n\n        return b\n    \n\nif __name__ == \"__main__\":\n    \n    q1 = MyFraction(12,8)\n    print(q1)\n\n    q2 = MyFraction(32,-8)\n    print(q2)\n\n    q3 = MyFraction(3.14)\n    print(q3)\n\n    q4 = MyFraction(q1)\n    print(q4)\n\n    q5 = MyFraction(\"Hola\",3)\n    print(q5)    \nSalida:\n3/2\n-4/1\n157/50\n3/2\nTraceback (most recent call last):\n  File \".\\notes\\posts\\fracciones\\ownfraction.py\", line 78, in &lt;module&gt;\n    q5 = MyFraction(\"Hola\",3)\n  File \".\\notes\\posts\\fracciones\\ownfraction.py\", line 29, in __init__\n    raise TypeError(\"unsupported types of arguments\")\nTypeError: unsupported types of arguments\nVemos que nuestro c√≥digo parece funcionar, sin embargo PEP 443 dice que ‚Äúactualmente es un antipatr√≥n com√∫n para el c√≥digo de Python inspeccionar los tipos de argumentos recibidos para decidir qu√© hacer con los objetos.‚Äù üò±üò±üò±\nAs√≠ que esta no parece ser una forma pyth√≥nica de hacerlo.\nUna mejor forma de tener m√∫ltiples constructores es utilizar m√©todos de clase, estos son m√©todos que pertenecen a la clase y no es necesario instanciar un objeto para poder utilizarlos.\nclass MyFraction:\n    \n    def __init__(self, p:int, q:int = 1) -&gt; None:\n        \n        if isinstance(p, int) and isinstance(q, int):\n            if q == 0:\n                raise ZeroDivisionError(\"the denominator should be non-zero\") \n            elif p == 0:\n                self.numerator = p\n                self.denominator = 1\n            else:\n                self.numerator = p\n                self.denominator = q\n                self.simplify()\n        else:\n            raise TypeError(\"arguments should be of integer type\")\n    \n    @classmethod\n    def from_float(cls, f:float):\n\n        if isinstance(f, float):\n            denominator = 1 \n            intarg = int(f)\n            while f - intarg &gt; 0.00001:\n                f *= 10\n                denominator *= 10\n                intarg = int(f)\n\n            return cls(intarg, denominator) \n        \n        else:\n            raise TypeError(\"argument should be of float type\")\n\n    @classmethod\n    def from_fraction(cls, fraction):\n\n        if isinstance(fraction, MyFraction):\n            return cls(fraction.numerator, fraction.denominator)\n        else:\n            raise TypeError(\"argument should be an instance of MyFraction\")\n        \n\n    def simplify(self):\n        \n        abs_n = abs(self.numerator)\n        abs_d = abs(self.denominator)\n        d = self.gcd(abs_n,abs_d)\n        self.numerator //= d\n        self.denominator //= d\n\n        if self.denominator &lt; 0:\n            self.numerator *= -1\n            self.denominator *= -1\n\n    def __str__(self) -&gt; str:\n        return f\"{self.numerator}/{self.denominator}\"\n    \n    @staticmethod\n    def gcd(a:int, b:int) -&gt; int:\n        \n        if a&lt;b:\n            a,b = b,a\n        \n        r = a % b\n        while r != 0:\n            \n            a = b\n            b = r\n            r = a % b\n\n        return b\n    \n\nif __name__ == \"__main__\":\n    \n    q1 = MyFraction(12,8)\n    print(q1)\n\n    q2 = MyFraction(32,-8)\n    print(q2)\n\n    q3 = MyFraction.from_float(3.14)\n    print(q3)\n\n    q4 = MyFraction.from_fraction(q2)\n    print(q4)\n\n    q5 = MyFraction.from_float(\"Hola\")\n    print(q5)    \nSalida:\n3/2\n-4/1\n157/50\n-4/1\nTraceback (most recent call last):\n  File \"C:\\Users\\Carlos\\Desktop\\ESFM\\learning_python\\notes\\posts\\fracciones\\ownfraction.py\", line 88, in &lt;module&gt;  \n    q5 = MyFraction.from_float(\"Hola\")\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\Users\\Carlos\\Desktop\\ESFM\\learning_python\\notes\\posts\\fracciones\\ownfraction.py\", line 32, in from_float\n    raise TypeError(\"argument should be of float type\")\nTypeError: argument should be of float type\nEn el c√≥digo anterior definimos los m√©todos de clase from_float() y from_fraction() para tener constructores alternativos que reciben diferentes tipos de argumentos y crean instancias de MyFraction.\n\n\n\n\n\n\nTip\n\n\n\nUna convenci√≥n popular en Python es usar el prefijo from para los constructores definidos como m√©todos de clase.\n\n\n\nUtilizando el decorador @singledispatchmethod.\nPodemos encontrar la siguiente definici√≥n en PEP 443:\n\n\n\n\n\n\nTip\n\n\n\nUna funci√≥n gen√©rica se compone de m√∫ltiples funciones que implementan la misma operaci√≥n para diferentes tipos. La implementaci√≥n que debe usarse durante una llamada est√° determinada por el algoritmo de env√≠o (dispatch algorithm). Cuando la implementaci√≥n se elige en funci√≥n del tipo de un solo argumento, esto se conoce como env√≠o √∫nico o single dispatch.\n\n\nA partir de Python 3.8 podemos utilizar el decorador @singledispatchmethod para convertir un m√©todo en una funci√≥n gen√©rica de env√≠o m√∫ltiple.\nfrom functools import singledispatchmethod\n\nclass MyFraction:\n\n    @singledispatchmethod\n    def __init__(self, arg1, arg2) -&gt; None:\n        raise TypeError(f\"unsupported type of arguments\")\n\n    @__init__.register(int)\n    def from_integers(self, p:int, q:int = 1) -&gt; None:\n\n        if not isinstance(q,int):\n          raise TypeError(\"the denominator should be an integer\")\n\n        if q == 0:\n            raise ZeroDivisionError(\"the denominator should be non-zero\")\n        elif p == 0:\n            self.numerator = p\n            self.denominator = 1\n        else:\n            self.numerator = p\n            self.denominator = q\n            self.simplify()\n\n    @__init__.register(float)\n    def from_float(self, f:float):\n\n        denominator = 1\n        intarg = int(f)\n        while f - intarg &gt; 0.00001:\n            f *= 10\n            denominator *= 10\n            intarg = int(f)\n\n        self.numerator = intarg\n        self.denominator = denominator\n        self.simplify()\n\n    @classmethod\n    def from_fraction(cls, fraction):\n\n        if isinstance(fraction, MyFraction):\n            return cls(fraction.numerator, fraction.denominator)\n        else:\n            raise TypeError(\"argument should be an instance of MyFraction\")\n\n\n    def simplify(self):\n\n        abs_n = abs(self.numerator)\n        abs_d = abs(self.denominator)\n        d = self.gcd(abs_n,abs_d)\n        self.numerator //= d\n        self.denominator //= d\n\n        if self.denominator &lt; 0:\n            self.numerator *= -1\n            self.denominator *= -1\n\n    def __str__(self) -&gt; str:\n        return f\"{self.numerator}/{self.denominator}\"\n\n    @staticmethod\n    def gcd(a:int, b:int) -&gt; int:\n\n        if a&lt;b:\n            a,b = b,a\n\n        r = a % b\n        while r != 0:\n\n            a = b\n            b = r\n            r = a % b\n\n        return b\n\n\nif __name__ == \"__main__\":\n\n    q1 = MyFraction(12,8)\n    print(q1)\n\n    q2 = MyFraction(32,-8)\n    print(q2)\n\n    q3 = MyFraction(3.14)\n    print(q3)\n\n    q4 = MyFraction.from_fraction(q2)\n    print(q4)\nSalida:\n3/2\n-4/1\n157/50\n-4/1\nEn el c√≥digo anterior hemos convertido el m√©todo __init__() en una funci√≥n gen√©rica que tiene una implementaci√≥n diferente para enteros (from_integers()) y para flotantes (from_float()). Sin embargo from_fraction() sigue siendo un m√©todo de clase debido a que al agregarlo como una implementaci√≥n m√°s con __init__.register(MyFraction), tenemos un error que nos dice que MyFraction no est√° definida.\n\n\n¬øQu√© aprendimos?\n\nA crear diferentes constructores, ya sea con m√©todos de clase o con funciones gen√©ricas.\n\n\n\nReferencias\n\nProviding Multiple Constructors in Your Python Classes por Leodanis Pozo Ramos en RealPython.\nTipos de M√©todos de clase en Python por Eduardo Ismael Garc√≠a P√©rez en PyWombat."
  }
]