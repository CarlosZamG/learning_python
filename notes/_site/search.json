[
  {
    "objectID": "posts/hola-mundo/index.html",
    "href": "posts/hola-mundo/index.html",
    "title": "Hola Mundo",
    "section": "",
    "text": "Hola Mundo!!!!\nDecid√≠ empezar este blog para documentar mi aprendizaje en Python.\nLos temas que planeo aprender (por ahora) son los siguientes:\n\n1. Interpretado vs Compilado.\n\n\n2. Funciones.\n\nScope.\nPar√°metros y argumentos.\nArgumentos opcionales y par√°metros con un valor por default.\nargs y kwargs.\nFunciones lambda.\nmap(),filter(), reduce().\n\n\n\n3. Estructuras de datos y strings.\n\nListas.\nIndexing y slicing.\nTuplas.\nDiccionarios\nArrays.\nFormateo de strings.\nComprenhensions.\n\n\n\n4. Programaci√≥n Orientada a Objetos.\n\nClases.\nHerencia.\nSobrecarga de operadores.\nEnum.\n\n\n\n4. Otros:\n\nManejo de archivos.\nExcepciones.\nassert.\nDecoradores."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Aprendiendo Python",
    "section": "",
    "text": "Ejemplo: Nuestra propia clase Fraction\n\n\n\n\n\n\n\nPOO\n\n\n\n\n\n\n\n\n\n\n\nAug 6, 2023\n\n\nCarlos Zamora\n\n\n\n\n\n\n  \n\n\n\n\nHola Mundo\n\n\n\n\n\n\n\n\n\n\n\n\nAug 5, 2023\n\n\nCarlos Zamora\n\n\n\n\n\n\nNo hay resultados"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/fracciones/index.html",
    "href": "posts/fracciones/index.html",
    "title": "Ejemplo: Nuestra propia clase Fraction",
    "section": "",
    "text": "En este blog documentar√© la creaci√≥n de mi propia clase para representar un n√∫mero racional.\nEmpezaremos con una clase MyFraction sencilla que tiene el constructor m√°s evidente que recibe dos n√∫meros enteros que representan el numerador y el denominador. Tambi√©n he agregado el m√©todo __str__() para poder mostrar nuestras instancias de manera legible con print().\nclass MyFraction:\n    \n    def __init__(self, numerator:int, denominator:int = 1) -&gt; None:\n        self.numerator = numerator\n        self.denominator = denominator\n\n    def __str__(self) -&gt; str:\n        return f\"{self.numerator}/{self.denominator}\"\n    \n\nif __name__ == \"__main__\":\n    \n    q1 = MyFraction(5,3)\n    q2 = MyFraction(8)\n    print(q1)\n    print(q2)\nSalida:\n5/3\n8/1\nVemos que este c√≥digo funciona bien cuando recibimos 1 o 2 enteros, sin embargo, puede no tener el efecto deseado al recibir valores de otro tipo:\nif __name__ == \"__main__\":\n    \n    q1 = MyFraction(\"hola\",3)\n    q2 = MyFraction(3.14, 2.72)\n    print(q1)\n    print(q2)\nSalida:\nhola/3\n3.14/2.72\nPodemos ver en la salida que nuestra instancia ya no representa un racional propiamente, esto se debe a que Python es un lenguaje de tipado din√°mico que no revisa los tipos de datos. Podemos pensar que la soluci√≥n a este problema implementar la revisi√≥n de tipos nosotros mismos.\nAntes de continuar, delimitemos nuestra clase, espec√≠ficamente nuestro constructor:\n\nRecibir√° 1 o 2 variables que representen enteros, √≥\nRecibir√° 1 variable que represente un flotante, √≥\nRecibir√° otra fracci√≥n.\n\nEste es el c√≥digo modificado:\nclass MyFraction:\n    \n    def __init__(self, arg1, arg2 = 1) -&gt; None:\n        \n        if isinstance(arg1, int) and isinstance(arg2, int):\n            if arg2 == 0:\n                raise ZeroDivisionError(\"the denominator should be non-zero\") \n            elif arg1 == 0:\n                self.numerator = arg1\n                self.denominator = 1\n            else:\n                self.numerator = arg1\n                self.denominator = arg2\n                self.simplify()\n        elif isinstance(arg1, float) and arg2 == 1:\n            intarg = int(arg1)\n            while arg1 - intarg &gt; 0.00001:\n                arg1 *= 10\n                arg2 *= 10\n                intarg = int(arg1)\n\n            self.numerator = intarg\n            self.denominator = arg2\n            self.simplify()\n        elif isinstance(arg1, MyFraction) and arg2 == 1:\n            self.numerator = arg1.numerator \n            self.denominator = arg1.denominator\n        else:\n            raise TypeError(\"unsupported types of arguments\")\n\n        \n\n    def simplify(self):\n        \n        abs_n = abs(self.numerator)\n        abs_d = abs(self.denominator)\n        d = self.gcd(abs_n,abs_d)\n        self.numerator //= d\n        self.denominator //= d\n\n        if self.denominator &lt; 0:\n            self.numerator *= -1\n            self.denominator *= -1\n\n    def __str__(self) -&gt; str:\n        return f\"{self.numerator}/{self.denominator}\"\n    \n    @staticmethod\n    def gcd(a:int, b:int) -&gt; int:\n        \n        if a&lt;b:\n            a,b = b,a\n        \n        r = a % b\n        while r != 0:\n            \n            a = b\n            b = r\n            r = a % b\n\n        return b\n    \n\nif __name__ == \"__main__\":\n    \n    q1 = MyFraction(12,8)\n    print(q1)\n\n    q2 = MyFraction(32,-8)\n    print(q2)\n\n    q3 = MyFraction(3.14)\n    print(q3)\n\n    q4 = MyFraction(q1)\n    print(q4)\n\n    q5 = MyFraction(\"Hola\",3)\n    print(q5)    \nSalida:\n3/2\n-4/1\n157/50\n3/2\nTraceback (most recent call last):\n  File \".\\notes\\posts\\fracciones\\ownfraction.py\", line 78, in &lt;module&gt;\n    q5 = MyFraction(\"Hola\",3)\n  File \".\\notes\\posts\\fracciones\\ownfraction.py\", line 29, in __init__\n    raise TypeError(\"unsupported types of arguments\")\nTypeError: unsupported types of arguments\nVemos que nuestro c√≥digo parece funcionar, sin embargo PEP 443 dice que ‚Äúactualmente es un antipatr√≥n com√∫n para el c√≥digo de Python inspeccionar los tipos de argumentos recibidos para decidir qu√© hacer con los objetos.‚Äù üò±üò±üò±\nAs√≠ que esta no parece ser una forma pyth√≥nica de hacerlo."
  }
]