[
  {
    "objectID": "posts/hola-mundo/index.html",
    "href": "posts/hola-mundo/index.html",
    "title": "Hola Mundo",
    "section": "",
    "text": "Hola Mundo!!!!\nDecidí empezar este blog para documentar mi aprendizaje en Python.\nLos temas que planeo aprender (por ahora) son los siguientes:\n\n1. Interpretado vs Compilado.\n\n\n2. Funciones.\n\nScope.\nParámetros y argumentos.\nArgumentos opcionales y parámetros con un valor por default.\nargs y kwargs.\nFunciones lambda.\nmap(),filter(), reduce().\n\n\n\n3. Estructuras de datos y strings.\n\nListas.\nIndexing y slicing.\nTuplas.\nDiccionarios\nArrays.\nFormateo de strings.\nComprenhensions.\n\n\n\n4. Programación Orientada a Objetos.\n\nClases.\nHerencia.\nSobrecarga de operadores.\nEnum.\n\n\n\n4. Otros:\n\nManejo de archivos.\nExcepciones.\nassert.\nDecoradores."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Aprendiendo Python",
    "section": "",
    "text": "Ejemplo: Nuestra propia clase Fraction\n\n\n\n\n\n\n\nPOO\n\n\n\n\n\n\n\n\n\n\n\nAug 6, 2023\n\n\nCarlos Zamora\n\n\n\n\n\n\n  \n\n\n\n\nHola Mundo\n\n\n\n\n\n\n\n\n\n\n\n\nAug 5, 2023\n\n\nCarlos Zamora\n\n\n\n\n\n\nNo hay resultados"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/fracciones/index.html",
    "href": "posts/fracciones/index.html",
    "title": "Ejemplo: Nuestra propia clase Fraction",
    "section": "",
    "text": "En este blog documentaré la creación de mi propia clase para representar un número racional.\nEmpezaremos con una clase MyFraction sencilla que tiene el constructor más evidente que recibe dos números enteros que representan el numerador y el denominador. También he agregado el método __str__() para poder mostrar nuestras instancias de manera legible con print().\nclass MyFraction:\n    \n    def __init__(self, numerator:int, denominator:int = 1) -&gt; None:\n        self.numerator = numerator\n        self.denominator = denominator\n\n    def __str__(self) -&gt; str:\n        return f\"{self.numerator}/{self.denominator}\"\n    \n\nif __name__ == \"__main__\":\n    \n    q1 = MyFraction(5,3)\n    q2 = MyFraction(8)\n    print(q1)\n    print(q2)\nSalida:\n5/3\n8/1\nVemos que este código funciona bien cuando recibimos 1 o 2 enteros, sin embargo, puede no tener el efecto deseado al recibir valores de otro tipo:\nif __name__ == \"__main__\":\n    \n    q1 = MyFraction(\"hola\",3)\n    q2 = MyFraction(3.14, 2.72)\n    print(q1)\n    print(q2)\nSalida:\nhola/3\n3.14/2.72\nPodemos ver en la salida que nuestra instancia ya no representa un racional propiamente, esto se debe a que Python es un lenguaje de tipado dinámico que no revisa los tipos de datos. Podemos pensar que la solución a este problema implementar la revisión de tipos nosotros mismos.\nAntes de continuar, delimitemos nuestra clase, específicamente nuestro constructor:\n\nRecibirá 1 o 2 variables que representen enteros, ó\nRecibirá 1 variable que represente un flotante, ó\nRecibirá otra fracción."
  }
]